<html>
<head>
<title>Javascript PC Emulator - Technical Notes</title>
</head>
<body>
<h2>Javascript PC Emulator - Technical Notes</h2>
By <a href="http://bellard.org">Fabrice Bellard</a> - May 14, 2011
<p>

This PC emulator is written in Javascript. The emulated hardware
consists in the following devices:
<ul>
<li>32 bit x86 compatible CPU
<li>8259 Programmble Interrupt Controller
<li>8254 Programmble Interrupt Timer
<li>16450 UART
<li>Real Time Clock.
</ul>

The code is written in pure Javascript using
the <a href="http://www.khronos.org/registry/typedarray/specs/latest/">W3C
Typed Arrays</a> which are available in some recent browsers. Only
this feature is tested to determine if a given browser can launch the
PC emulator. It was tested with
<a href="http://www.mozilla.com/fr/firefox/">Firefox 4</a>
and <a href="http://www.google.com/chrome/">Google Chrome 11</a> on
Linux, Window and Mac (it does not work with Chrome 12 beta. As far as
I know, it is a bug in the browser). In any case, a fast Javascript
engine is needed to have good performance.

<p>
<h3>CPU Emulation</h3>

Some of the code is inspired from my x86 dynamic translator present
in <a href="http://qemu.org">QEMU</a>, but there are important
differences because here it is an interpreter. The CPU is close to a
486 compatible x86 without FPU. The lack of FPU is not a problem when
running Linux as Operating System because it contains a FPU
emulator. In order to be able to run Linux, a complete MMU is
implemented. The exact restrictions of the emulated CPU are:
<ol>
<li>No FPU/MMX/SSE
<li>No segment limit and right checks when accessing memory (Linux
does not rely on them for memory protection, so it is not an
issue. The x86 emulator of QEMU has the same restriction).
<li>No CS/DS/ES/SS segment overrides. FS/GS overrides are implemented
because they are needed for Thread Local Storage in Linux.
<li>A few seldom used instructions are missing (BCD operations, BOUND, ...).
<li>No single-stepping
<li>No real mode
<li>No 16 bit protected mode (although most 16 bit instructions are
present because they are needed to run 32 bit programs).
</ol>
Most of these restrictions are easy to remove, but I decided to
implement the strict minimum to be able to use a recent Linux kernel
and its user applications.
<p>
I added some tricks which are not present in QEMU to be more precise
when emulating unaligned load/stores at page boundaries. The
condition code emulation is also more efficient than the one in QEMU.

<h3>Devices</h3>

Currently there is no synchronization between the PIT frequency and
the real time, so there is a variable drift between the time returned
by Linux (try the "date" command) and the real time.
<p>
The UART (serial port) does not support FIFO mode. Perhaps it could
help to improve the display speed.
<p>
There is no network emulation at this point.
<p>
A clipboard device (seen as <tt>/dev/clipboard</tt> in the emulator)
was added to allow exchange of data between the emulator and the
outside world.

<h3>Javascript terminal</h3> 

Although I could have reused the
excellent <a href="http://www.masswerk.at/termlib/">termlib</a>, I
decided to write my own because I was curious to see how it could be
done. The main problem is the key handling which is different among
browsers and OSes, as
described <a href="http://unixpapa.com/js/key.html">here</a>.

<h3>Linux distribution</h3> 

I compiled a 2.6.20 Linux kernel (I guess any other version would work
provided there is still an FPU emulator). The configuration
is <a href="config_linux-2.6.20">here</a> and there is a small
optional <a href="patch_linux-2.6.20">patch</a> to avoid outputting
warnings due to the slow serial port. An uncompressed kernel image is
used instead of a compressed one to have a faster boot. It is
generated with "objcopy -O binary vmlinux vmlinux.bin".
<p>
The disk image is just a ram disk image loaded at boot time. It
contains a filesystem generated
with <a href="http://buildroot.uclibc.org/">Buildroot</a> containing
<a href="http://www.busybox.net/">BusyBox</a>. I added my toy C
compiler <a href="http://bellard.org/tcc">TinyCC</a> and my unfinished
but usable emacs clone <a href="http://bellard.org/qemacs">QEmacs</a>.

<p>

<h3>Javascript</h3>

I happen to be interested by the implementation of Javascript engines
these days - but I don't know yet if I will write my own any time soon
! Anyway, this emulator was a way to learn how to write optimized code
for recent Javascript engines, in particular Jaeger Monkey (for
Firefox 4) and V8 (for Chrome).
<p>
A troubling thing is that the PC emulator is about 2 times slower
using V8 than Jaeger Monkey (I used the 32 bit version for both). I
have no precise explanation yet because I only looked at the Jeager
Monkey code so far.

<h3>What's the use ?</h3>

I did it for fun, just because newer Javascript Engines are fast
enough to do complicated things. Real use could be:
<ul>
<li>Benchmarking of Javascript engines (how much time takes your
Javascript engine to boot Linux ?). For this particular application,
efficient handling of 32 bit signed and unsigned integers and of typed
arrays is important.
<li>Learning to use command line Unix tools without leaving the browser.
<li>Client side processing using an x86 library, for example for
cryptographic purposes. For such application, the x86 emulator can be
modified to provide an API to load x86 dynamic libraries and to
provide
a <a href="https://developer.mozilla.org/en/js-ctypes/Using_js-ctypes">js-ctypes</a>
like API to call the C/C++ functions from javascript.
<li>A more advanced version would allow to use old DOS PC software
such as games.
</ul>
<p>
<a href="index.html">[Back to the PC emulator]</a>
</body>
</html>
